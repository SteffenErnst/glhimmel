        "float opticalDepth(float H, float r, float mu) {\n"
        "    float result = 0.0;\n"
        "    float dx = limit(r, mu) / float(TRANSMITTANCE_INTEGRAL_SAMPLES);\n"
        "    float xi = 0.0;\n"
        "    float yi = exp(-(r - u_apparentAngularRadius) / H);\n"
        "    for (int i = 1; i <= TRANSMITTANCE_INTEGRAL_SAMPLES; ++i) {\n"
        "        float xj = float(i) * dx;\n"
        "        float yj = exp(-(sqrt(r * r + xj * xj + 2.0 * xj * r * mu) - u_apparentAngularRadius) / H);\n"
        "        result += (yi + yj) / 2.0 * dx;\n"
        "        xi = xj;\n"
        "        yi = yj;\n"
        "    }\n"
        "    return mu < -sqrt(1.0 - (u_apparentAngularRadius / r) * (u_apparentAngularRadius / r)) ? 1e9 : result;\n"
        "}\n"
        "\n"
        "void main() {\n"
        "    float r, muS;\n"
        "    getTransmittanceRMu(r, muS);\n"
        "    vec3 depth = betaR * opticalDepth(HR, r, muS) + betaMEx * opticalDepth(HM, r, muS);\n"
        "    gl_FragColor = vec4(exp(-depth), 0.0);\n" // Eq (5)
        "}"